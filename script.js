#!/usr/bin/env node

const dgram = require('dgram');
const fs = require('fs');
const os = require('os');
const dotenv = require('dotenv');
const { execSync } = require('child_process'); // !! used ONLY for checking if pactl is installed and creating a loopback sink !!
const { Transform } = require('stream');
const fft = require('fft-js').fft;
const fftUtil = require('fft-js').util;

// Check if we're on Linux
if (os.platform() !== 'linux') {console.error('This app can only run on Linux.');process.exit(1);}
// CHeck if pactl exists
try {execSync('which pactl', {stdio: 'ignore'});} catch (e) {console.error("Pulseaudio is not installed or pactl doesn't exist.");process.exit(1);}
// Uninstall if --uninstall is present
if (process.argv.slice(2).includes("--uninstall")) {if (!fs.existsSync(os.homedir() + '/.audiosync.env')) {console.error("Couldn't find the .audiosync.env file. There's probably nothing to uninstall.");process.exit(1);}execSync('pactl list short modules').toString().split('\n').filter(line => line.includes('wled')).map(line => parseInt(line.split('\t')[0],10)).filter(id => !isNaN(id)).forEach(id => {try {execSync(`pactl unload-module ${id}`);console.log(`Unloaded module ${id}`)} catch (e) {console.warn(`Failed to unload module ${id}:`, e.message);process.exit(1)}});fs.unlinkSync(os.homedir() + '/.audiosync.env');console.log(`Done! The last thing you have to do is delete this binary.`);process.exit(1);}
// Create default config file
function createDefaultEnv() {fs.writeFileSync(`${os.homedir()}/.audiosync.env`, `# Generated by WLED-AudioSync - The loopback file is at ${os.homedir()}.audiosync\n# To uninstall, run the app with --uninstall as an argument. Do not try to delete the loopback file unless you unlink the module.\nWLED_IP_ADDRESS='0.0.0.0'\nWLED_UDP_PORT=11988\nUSE_BROADCAST=true\nSAMPLE_RATE=44100\nCHUNK_SIZE=512`.trim(), {encoding: 'utf-8'});console.log(`Created an .audiosync.env file in your home directory. Broadcasting by default.`);dotenv.config({path: os.homedir() + '/.audiosync.env'})}

// Check if this is a first install, create loopback file if it is.
if (!fs.existsSync(os.homedir() + '/.audiosync.env')) {createDefaultEnv();} else {dotenv.config({path: os.homedir() + '/.audiosync.env'});}
if (!fs.existsSync(os.homedir() + '/.audiosync')) {try {const getSource = execSync('pactl list short sources').toString().split('\n').find(line => line.includes('RUNNING'))?.split('\t')[1] || null;if (!getSource) throw 'Start playing some music before you run this.';execSync(`pactl load-module module-pipe-sink sink_name=wled file=${os.homedir()}/.audiosync format=s16le rate=44100 channels=1`).toString().trim();execSync(`pactl load-module module-loopback source=${getSource} sink=wled`).toString().trim();} catch (e) {console.error(e.message || e);process.exit(1);}}

function processAudio(buffer) {
  if (buffer.length === 0) return null;

  const audio = new Int16Array(buffer.buffer, buffer.byteOffset, buffer.length / 2);
  const rms = Math.sqrt(audio.reduce((sum, val) => sum + val * val, 0) / audio.length);
  const silenceThreshold = 100;
  const isSilent = rms < silenceThreshold;

  let fftValues = new Array(16).fill(0);
  let rawLevel = 0.0, peakLevel = 0, fftSum = 0.0, peakFreq = 0.0;

  if (!isSilent) {
    let normalized = Array.from(audio, x => Math.max(-1, Math.min(1, x / 32768)));
    const absNormalized = normalized.map(Math.abs);

    const targetLength = Math.pow(2, Math.ceil(Math.log2(normalized.length))); // ahh this is how to find the nearest power of 2.. if only they taught that in school
    if (normalized.length < targetLength) {
      const padding = new Array(targetLength - normalized.length).fill(0);
      normalized = normalized.concat(padding);
    } else if (normalized.length > targetLength) {
      normalized = normalized.slice(0, targetLength);
    }

    const fftResult = fft(normalized);
    const magnitudes = fftUtil.fftMag(fftResult);

    const maxMag = Math.max(...magnitudes);
    const normMagnitudes = magnitudes.map(m => (m / maxMag) * 255);
    fftValues = normMagnitudes.slice(0, 16).map(v => Math.floor(v));

    rawLevel = absNormalized.reduce((a, b) => a + b, 0) / absNormalized.length;
    peakLevel = Math.max(...absNormalized) * 255;
    fftSum = magnitudes.reduce((a, b) => a + b, 0);
    const peakIndex = magnitudes.indexOf(maxMag);
    peakFreq = peakIndex * (parseInt(process.env.SAMPLE_RATE) / normalized.length);
  }
  // this probably isn't perfectly protocol compliant but it works damn it!
  const header = Buffer.from('00002');
  const packet = Buffer.alloc(6 + 2 + 4 + 4 + 1 + 1 + 16 + 2 + 4 + 4);
  let offset = 0;
  header.copy(packet, offset); offset += 6;
  packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  packet.writeFloatLE(rawLevel, offset); offset += 4;
  packet.writeFloatLE(rawLevel, offset); offset += 4;
  packet.writeUInt8(peakLevel, offset++);
  packet.writeUInt8(0, offset++);
  fftValues.forEach(val => packet.writeUInt8(val, offset++));
  packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  packet.writeFloatLE(fftSum, offset); offset += 4;
  packet.writeFloatLE(peakFreq, offset);

  return packet;
}

const audioStream = fs.createReadStream(os.homedir() + '/.audiosync', { encoding: 'binary' });
let bufferAccumulator = Buffer.alloc(0);

audioStream.on('data', (data) => {
  bufferAccumulator = Buffer.concat([bufferAccumulator, Buffer.from(data, 'binary')]);

  while (bufferAccumulator.length >= parseInt(process.env.CHUNK_SIZE) * 2) {
    const chunk = bufferAccumulator.slice(0, parseInt(process.env.CHUNK_SIZE) * 2);
    bufferAccumulator = bufferAccumulator.slice(parseInt(process.env.CHUNK_SIZE) * 2);

    const packet = processAudio(chunk);
    if (packet) {
      const targetIP = process.env.USE_BROADCAST == "true" ? "255.255.255.255" : process.env.WLED_IP_ADDRESS;
      udpSocket.send(packet, 0, packet.length, parseInt(process.env.WLED_UDP_PORT), targetIP);
    }
  }
});

const udpSocket = dgram.createSocket('udp4');
if (process.env.USE_BROADCAST) {udpSocket.bind(() => {udpSocket.setBroadcast(true);});}


// make a packet with all values at 0 when shutting down. prevents wled from getting stuck on the same FFT values until relaunch
// there also happens to be a race condition here and I have no clue how to fix it - sometimes it works and sometimes it doesn't.
function nullPacket() {
  const header = Buffer.from('00002');
  const packet = Buffer.alloc(6 + 2 + 4 + 4 + 1 + 1 + 16 + 2 + 4 + 4);
  let offset = 0;
  header.copy(packet, offset); offset += 6;
  packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  packet.writeFloatLE(0.0, offset); offset += 4;
  packet.writeFloatLE(0.0, offset); offset += 4;
  packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  for (let i = 0; i < 16; i++) packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  packet.writeUInt8(0, offset++);
  packet.writeFloatLE(0.0, offset); offset += 4;
  packet.writeFloatLE(0.0, offset);
  return packet;
}

function sendNullPacket() {const zeroPacket = nullPacket();const targetIP = process.env.USE_BROADCAST == "true" ? "255.255.255.255" : process.env.WLED_IP_ADDRESS;udpSocket.send(zeroPacket, 0, zeroPacket.length, process.env.WLED_UDP_PORT, targetIP, () => {process.exit();});}

process.on('SIGINT', sendNullPacket);
process.on('SIGTERM', sendNullPacket);

console.log(`Steaming to ${process.env.USE_BROADCAST == "true" ? '255.255.255.255' : process.env.WLED_IP_ADDRESS}:${parseInt(process.env.WLED_UDP_PORT)}`);
